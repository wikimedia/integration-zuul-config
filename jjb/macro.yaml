# Lint whitespace in directory {dir}. Usefull when the Git repository has
# been fetched out in some subdirtory of the Workspace. Example:
#
#  builder:
#    - lint-whitespaces-in:
#       dir: "$WORKSPACE/extensions/Foobar"
#
- builder:
    name: lint-whitespaces-in
    builders:
        - shell: "git --work-tree=\"{dir}\" diff --color --check HEAD^..HEAD"

# Lint whitespaces under $WORKSPACE. This is most probably the one you
# want to use. Example:
#
# builder:
#  - lint-whitespaces
#
- builder:
    name: lint-whitespaces
    builders:
     - lint-whitespaces-in:
        dir: '$WORKSPACE'

- builder:
    name: npm-install
    builders:
    - shell: |
        . /srv/deployment/integration/slave-scripts/bin/npm-setup.sh
        node --version
        npm --version
        rm -rf node_modules
        npm install

- builder:
    name: npm
    builders:
    - shell: |
        . /srv/deployment/integration/slave-scripts/bin/npm-setup.sh
        node --version
        npm --version
        rm -rf node_modules
        npm install
        npm test

# The npm-run macro is intended to be used when multiple scripts are used
# together (e.g. 'doc' and later 'test'). If you simply need to run
# npm-install and npm-run-test, use the plain 'npm' macro instead.
#
# MUST run npm-setup.sh before this (e.g. via npm-install macro)
#
# Example:
# builders:
#  - npm-run:
#      script: doc
#
- builder:
    name: npm-run
    builders:
     - shell: |
        . /srv/deployment/integration/slave-scripts/bin/npm-set-env.sh
        npm run-script {script}

- builder:
    name: assert-env-doc_subpath
    builders:
     - shell: |
         if [ -z $DOC_SUBPATH ]; then
             echo "\$DOC_SUBPATH is missing. Can not publish."
             exit 1
         fi

# Assert 'php' is phpflavor
#
# Parameter:
# * phpflavor: 'hhvm' or 'zend' or 'php55'
#
- builder:
    name: assert-phpflavor
    builders:
        - shell: |
            #!/bin/bash -eu
            PHP_VERSION=`php --version`

            case "{phpflavor}" in
                ( 'hhvm' )
                    MATCHER='^HipHop'
                ;;
                ( 'zend' )
                    MATCHER='^Zend Engine'
                ;;
                ( 'php53' )
                    MATCHER='^PHP 5\.3'
                ;;
                ( 'php55' )
                    MATCHER='^PHP 5\.5'
                ;;
                ( 'php56' )
                    MATCHER='^PHP 5\.6'
                ;;
                ( 'php70' )
                    MATCHER='^PHP 7\.0'
                ;;
                ( * )
                    echo "Invalid phpflavor '{phpflavor}' for JJB macro 'assert-phpflavor'"
                    echo "Must be either 'hhvm' or 'zend'"
                    exit 1
                ;;
            esac

            if ( echo "$PHP_VERSION" | egrep "$MATCHER" > /dev/null ); then
                echo -e "php is {phpflavor}:\n\n$PHP_VERSION\n"
            else
                echo -e "Assertion error: php is not {phpflavor}:\n\n$PHP_VERSION\n"
                exit 1
            fi

- builder:
    name: 'hhvm-clear-hhbc'
    builders:
        - shell: |
            rm -f *.hhbc

# Assert node version matches a basic regular expressions
#
# Parameter:
# * version: passed to `grep`
#
- builder:
    name: assert-node-version
    builders:
     - shell: |
         #!/bin/bash -e -u
         NODE_VERSION=`node --version`

         if ( echo "$NODE_VERSION" | grep "{version}" > /dev/null )
         then
             echo "Node version $NODE_VERSION matches '{version}'"
         else
             echo "Assertion error: node version $NODE_VERSION does not match '{version}'"
             exit 1
         fi

- builder:
    name: assert-node-version-0.8
    builders:
     - assert-node-version:
         version: ^v0[.]8[.]

- builder:
    name: assert-node-version-0.10
    builders:
     - assert-node-version:
         version: ^v0[.]10[.]

- builder:
    name: assert-node-version-4
    builders:
     - assert-node-version:
         version: ^v4[.]

- builder:
    name: assert-node-version-6
    builders:
     - assert-node-version:
         version: ^v6[.]

# Expose the current MediaWiki install path in http://localhost:9412
#
- builder:
    name: prepare-localhost
    builders:
     - shell: |
        # Load context (e.g. MW_INSTALL_PATH, MW_SERVER, MW_SCRIPT_PATH)
        . /srv/deployment/integration/slave-scripts/bin/mw-set-env-localhost.sh

        # Configure MediaWiki
        echo -e \
         "<?php\n\$wgServer = '${MW_SERVER}';\n"\
         "\$wgScriptPath = '${MW_SCRIPT_PATH}';\n"\
         "\$wgScript = \$wgStylePath = \$wgLogo = false;\n"\
         "\$wgResourceBasePath = null;\n"\
         "\$wgEnableJavaScriptTest = true;\n?>\n" >> "$MW_INSTALL_PATH/LocalSettings.php"

        # The location is free or we make it free
        PUBLIC_DIR="/srv/localhost-worker/$BUILD_TAG"
        test ! -e "$PUBLIC_DIR" || rm "$PUBLIC_DIR";

        # Publish our install in the QUnit server document root
        ln -s "$MW_INSTALL_PATH" "$PUBLIC_DIR"

        # Fetch headers and content preview for debugging (HTTP 500 Error, Database error, ResourceLoader etc.)
        # NB: Avoid "curl: Failed writing body" error when using 'head'. Either by using 'tac|tac', or by ignoring stderr,
        # or by writing to a file first and running 'head' on that.
        curl --include "${MW_SERVER}${MW_SCRIPT_PATH}/index.php/Special:BlankPage" > log/curl-SpecialBlankPage.log; head -n42 log/curl-SpecialBlankPage.log
        curl --include "${MW_SERVER}${MW_SCRIPT_PATH}/load.php?debug=true&modules=startup&only=scripts" > log/curl-load-startup.log; head -n42 log/curl-load-startup.log
        curl --include "${MW_SERVER}${MW_SCRIPT_PATH}/index.php?title=Special:JavaScriptTest/qunit/export" > log/curl-SpecialJavaScriptTest.log; head -n11 log/curl-SpecialJavaScriptTest.log

# qunit
#
- builder:
    name: qunit-karma
    builders:
     - prepare-localhost
     - shell: |
        . /srv/deployment/integration/slave-scripts/bin/mw-set-env-localhost.sh
        cd $MW_INSTALL_PATH
        . /srv/deployment/integration/slave-scripts/bin/npm-setup.sh
        rm -rf node_modules
        npm install
        ./node_modules/.bin/grunt karma:main

# similar to qunit-karma
- builder:
    name: npm-install-selenium
    builders:
     - shell: |
        . /srv/deployment/integration/slave-scripts/bin/mw-set-env-localhost.sh
        cd $MW_INSTALL_PATH
        . /srv/deployment/integration/slave-scripts/bin/npm-setup.sh
        rm -rf node_modules
        npm install

# mw-selenium
#
# Run MW-Selenium tests that are marked with the @integration tag against a
# local instance of MediaWiki. All setup of intial state for these kinds of
# tests should be done by the test suite via the API, including creation of
# the test user.

- builder:
    name: mw-selenium-nodepool
    builders:
     - prepare-localhost
     - shell: |
         # Fail whenever $EXT_NAME is not set
         set -u
         # Change to the working directory. EXT_NAME is set by Zuul parameters
         # functions
         cd "{tests-dir}"
         . '/srv/deployment/integration/slave-scripts/bin/mw-selenium-setup.sh'
         bundle install --verbose
         bundle exec cucumber \
            --color \
            --tags @integration \
            --tags ~@skip \
            --format pretty \
            --format junit --out $WORKSPACE/log/junit

- builder:
    name: mw-apply-settings
    builders:
     - shell: "/srv/deployment/integration/slave-scripts/bin/mw-apply-settings.sh"

- builder:
    name: mw-fetch-composer-dev
    builders:
     - shell: "/srv/deployment/integration/slave-scripts/bin/mw-fetch-composer-dev.sh"

- builder:
    name: mw-run-update-script
    builders:
        - shell: "/srv/deployment/integration/slave-scripts/bin/mw-run-update-script.sh"

- builder:
    name: mw-install-sqlite
    builders:
     - shell: "/srv/deployment/integration/slave-scripts/bin/mw-install-sqlite.sh"

- builder:
    name: mw-install-mysql
    builders:
     - shell: "/srv/deployment/integration/slave-scripts/bin/mw-install-mysql.sh"

- publisher:
    name: mw-teardown
    publishers:
     - postbuildscript:
         builders:
          - shell: "/srv/deployment/integration/slave-scripts/bin/mw-teardown.sh"
         # Postbuild options are confusing, setting both to false ensures the script always runs.
         onsuccess: False
         onfailure: False

- builder:
    name: mw-run-phpunit-allexts
    builders:
      - shell: '/srv/deployment/integration/slave-scripts/bin/mw-run-phpunit-allexts.sh'

# Generic phpunit builder, output junit log
# Should be used with publisher 'phpunit-junit'
- builder:
    name: phpunit-junit
    builders:
     - shell: 'mkdir -p log && /srv/deployment/integration/phpunit/vendor/bin/phpunit --log-junit log/junit-phpunit.xml'

# Publish PHPUnit junit results as generated by phpunit-junit builder
- publisher:
    name: phpunit-junit
    publishers:
     - xunit:
        types:
         - phpunit:
            pattern: 'log/junit-phpunit.xml'

# Used
- publisher:
    name: phpunit-junit-2
    publishers:
     - xunit:
        types:
         - phpunit:
            pattern: 'log/junit-mw-phpunit.xml'

- builder:
    name: phplint
    builders:
     - shell: |
        . /srv/deployment/integration/slave-scripts/bin/global-set-env.sh
        php --version
        /srv/deployment/integration/slave-scripts/bin/git-changed-in-head php php5 inc phtml module install \
        | xargs --no-run-if-empty -n1 -t php -l

- publisher:
    name: archive-log-dir
    publishers:
     - archive:
        artifacts: 'log/*'

- publisher:
    name: archive-log-allow-empty
    publishers:
     - archive:
        artifacts: 'log/*'
        allow-empty: true

# Validate a composer.json
- builder:
    name: composer-validate
    builders:
     - shell: |
        set -u
        cd "{dir}"
        [[ -f "composer.json" ]] || exit 0
        composer --ansi validate --no-check-publish

# Validate a composer.json so it can be published on packagist.org
- builder:
    name: composer-validate-package
    builders:
     - shell: |
        composer --ansi validate

# Example:
#
# builder:
#  - composer-update:
#     dir: 'src'
#
# Notes:
# `composer update` is being passed `--prefer-dist` to download cacheable
# tarballs when possible.
#
- builder:
    name: composer-update
    builders:
     - shell: |
        set -ux
        cd "{dir}"
        [[ -f "composer.json" ]] || exit 0
        export HTTP_PROXY_REQUEST_FULLURI=false
        export HTTPS_PROXY_REQUEST_FULLURI=false
        composer update --ansi --no-progress --prefer-dist --profile -v

- builder:
    name: composer-install
    builders:
     - shell: |
        set -ux
        cd "{dir}"
        [[ -f "composer.json" ]] || exit 0
        export HTTP_PROXY_REQUEST_FULLURI=false
        export HTTPS_PROXY_REQUEST_FULLURI=false
        composer install --ansi --no-progress --prefer-dist --profile -v

- builder:
    name: composer-local-create
    builders:
     - shell: |
        set -u
        cd src
        /srv/deployment/integration/slave-scripts/bin/mw-create-composer-local.py "{deps}" composer.local.json

# Runs "composer test"
#
# Example:
#
# builder:
#  - composer-test:
#      dir: 'src/extensions/$EXTNAME'
- builder:
    name: composer-test
    builders:
     - shell: |
        cd "{dir}"
        [[ -f "composer.json" ]] || exit 0
        COMPOSER_PROCESS_TIMEOUT=600 composer --ansi test

# Sends job duration (ms) to a statsd timer if node is labeled "stats-*",
# allowing for the collection and analysis of job performance on different
# groups of nodes.
#
# The stat keys created are "jenkins.{label}" where {label} is the "stats-*"
# node label. Note that job name is not included in the key, so only schedule
# this publisher for one job at a time to collect stats from builds of a
# consistent set of conditions (job, project, branch, etc.).
#
- publisher:
    name: record-node-stats
    publishers:
     - groovy-postbuild:
        script: !include-raw: record-node-stats.groovy
